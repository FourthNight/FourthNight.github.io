---
layout: article
title: 一起来做调试器叭叭叭
mathjax: true
excerpt_separator: <!--more-->
key: 2018-07-21-GHNote
tags: 读书笔记
---
  昨天借了一本逆向的书，昨晚把环境给搭建好了，PyDev写Python真是十分好用啊，今天按着书上走，写了一点调试器，这里把概念理一理。  
  下面是读书笔记哈。  
<!--more-->    
## 动态链接库
  动态链接库的本质是一些经过编译的二进制文件，其只有在运行时才会被链接进主进程（所以叫他“动态”）。  
  Python里，要调用这些链接库函数，需要我们自行解析出函数的地址（大致是通过地址来调用函数吧）。Python自带的ctype库可以简化这个问题。  
  下列代码来自阅读书目：
```
from ctypes import *
msvcrt = cdll.msvcrt
message_string = “Hello world!\n”
msvcrt.printf(“Testing: %s”, message_string)
```
  输出结果为：
```
Testing: Hello world!
```
  上述代码中，cdll()为动态链接库的加载方式，msvcrt.dll为一个动态链接库，printf为其所包含的函数，现在其通过python的语法调用。  
## 指针传递参数
  C语言中，经常可见用指针作为函数的参数（尤其是参数值体积较大时）。ctype库中byref()函数可使得python中也可有相似的做法。你可以进行如下操作，定义一个参数值为指针的函数：
```
function_main(byref(parameter))
…
```
## 结构体与联合体
  ctypes使得我们可以在python里构建出兼容与C的结构体类型。  
```
class biubiubiu(Structure):
　　_fields_ = [
　　(“bebebe”,c_int),
　　(“fufufu”,c_int),
　　]
```
  上述代码定义了结构体名字为biubiubiu，结构体内部定义了变量bebebe和变量fufufu，其ctype类型为c_int（相当于c中的int，python中的int/long类型）。调用结构体内部变量的办法还是biubiubiu.bebebe这类方式。  
  联合体与结构体不同，联合体的所有变量共享一个内存地址，相当于一个值在各种数据类型下的表示。联合体定义方式如下：
```
class biubiubiu(Union)
   _fields_ = [
   (“bebebe”,c_int),
   (“fufufu”,c_char * 8)
   ]
```
  此时，若定义结构体参数为67，则biubiubiu.bebebe为整型的67，fufufu为字符型的67，对应ASCII码中为C。  

## 调试器
  调试器可以让我们跟踪一个进程的运行时状态。  
  调试器分为白盒调试器和黑盒调试器。  
　白盒调试器是从源码为信息来源，可以对被调试的进程获取较高级别的控制能力。比如咱们敲代码的框框（IDE）中就会有一个内建调试器（比如MATLAB里），告诉你哪边出错了，哪个变量名字没定义哇。  
  黑盒调试器是假设分析的目标是一个完全不透明的黑盒，通过黑盒的输出结果来发现软件的漏洞和缺陷。一般来说，我们很难获取到软件的源代码，很多情况下我们必须使用黑盒调试器来对目标程序进行跟踪。  
  黑盒调试器分为两类，用户态调试器和内核态调试器。  
  用户态是指CPU处理器在执行应用程序代码时所处的一种特定状态，用户态下的应用程序是以最低权限运行的。比如打开网易云音乐，听个歌，搜个歌儿啥的就是用户态层级上的交互。若要对此类进程进行跟踪，只要用一个用户态调试器即可。  
  内核态是指最高级别的权限运行。底层组件是运行在内核态下的，emmmm..举不出例子。  
## 寄存器
  寄存器是位于CPU上的小型存储器。CPU上一般有8个通用寄存器：EAX、EDX、ECX、ESI、EDI、EBP、ESP和EBX。  
  EAX：累加器。做常见的运算操作及传递函数调用的返回值。  
  EDX：看做是EAX的延伸。EDX也可以用于通用目的的数据储存，常见的用法还是和EAX结合使用，协助执行复杂的运算。  
  ECX：计数器。用于支持循环操作。ECX寄存器是反向计数的，因为汇编中的计数是反向进行的。（我也不知道这有啥联系，以后可能会相通吧）  
  ESI、EDI：数据处理的循环操作依赖于这两个寄存器。ESI为源变址寄存器，存储输入数据流的位置信息。EDI为目的变址寄存器，指向相关数据操作结果的存放位置。ESI用于读，EDI用于写。  
  ESP和EBP：这两个寄存器用于控制函数的调用和相关的栈操作。当一个函数被调用时，其调用参数连同函数的返回地址先后被压入栈中。ESP寄存器始终指向函数的顶端，即指向函数的返回地址。（有形参时候不是指向形参的嘛，这里到底嘛意思？）EDP指向每栈帧的底部。  
  EBX：该寄存器没有被指定特殊用途，可以被当做额外的储存单元来使用。  
  EIP：EIP不是8个通用寄存器之一，但它能始终指向当前正在执行的指令，能够实时更新反映当前代码执行到的位置。  
## 栈
　栈中存储着函数被调用的相关信息。栈实际上就是一个满足前进后出规则的线性表。
## 调试事件
  调试器的内部是无限循环的。有调试事件发生时，调试器被激活，调用相应的处理例程（啥是处理例程？预先设计好的步骤？）处理事件，然后进入待机状态，等待下一个调试事件的发生。  
  当处理例程被调用时，被调试的目标进程暂停执行并等待调试器做出如何继续的指示。意思就是，调试器被激活了，被调试的目标就暂停执行任务了，调试器就会按预先设置好的处理例程来给目标下指示。  
  调试器必须捕获的几种常见调试事件：
* 断点触发；  
* 非法内存操作；  
* 被调试程序报出异常。  
  
